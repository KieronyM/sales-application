# sales-application
## Why are we doing this?
The purpose of this application is to provide a user with an easy to use interface for a sales database. It will allow the user to create sales records and generate certain reports by navigating a command line menu rather than needing to directly access the MySQL database. This helps keep the data safe from accidental or intentional harm and means that the end user requires no coding knowledge. In all, it should reduce errors and make workflows more efficient, especially as the dataset expands.

## How I expected the challenge to go
Unlike the HTML/CSS/JS challenge, I found this to be a much more intensive project than I expected. I had thought that this would be a simple case of creating a menu that triggered its respective function, but this proved not to be the case. To avoid replicating code, I ended up with more functions than menu options but I'm happy with this as it gives scope to expand in the future and is easy to read. I found that whilst creating the menus took as much time as I expected, simple debugging took much longer. This was because many errors only occur at compile time, and in general C# errors are less descriptive than JavaScript ones. It's also more strongly typed and the MySQL package tends to just error saying the command could not be executed without providing more details, which takes time to diagnose. However, I did enjoy the challenge more than I expected to which is a big plus!

## What went well?
Having spent time doing them in the Academy, creating menus to navigate through and while loops to allow the user to retry was fast and simple. I expanded this by applying some of my own research on 'TryParse' blocks, which allow nice error handling when the user accidentally makes an invalid entry. I expanded this error handling to the MySQL operations, creating a MySQLService class for all database operations, and then functions within this class that connect to the database automatically and display errors correctly when this fails (as it did several times in development!). I was also comfortable with the necessary MySQL commands to produce the data that I needed, and felt comfortable using the documentation to find the correct YEAR and MONTH functions required to filter the data. I'd also add that starting from the ground up, I felt happy with how to split my code into classes and feel that I have made good use of classes to divide my code logically. 

## What didn't go as well?
Creating a MySQL database with the required table on my machine was OK, but to make that data accessible to others was going to be tricky. I could not find a way to export the data in a way that it could be easily imported, so I instead opted to use a free hosting service to put my database on the web. This has the benefit of being easy to access, but I did find that the configuration was much more difficult. I did overcome this by finding a "No SSL" flag which enabled me to use the data over an unsecured connection which worked. Another problem that arose was that the MySQL Server version used on my hosting service only supported MySQL 5.8. In practice, this meant that I could not default the salesDate field to the current date and instead had to use a timestamp. I would overcome this in a production environment by upgrading to MySQL Server v8 or above.  

Another thing that didn't go as well was learning to show data as a table. Previously, I had only pulled 1 column of data which was easy to represent on each line. However, this task required me to get show multiple columns, which was trickier than expected. After some in depth research I did find a way to do this, and whilst it does not look perfect I have used a combination of padding and colour changes to clearly represent the data. 

## Possible improvements for the future
The natural first improvement I would make would be to add a GUI to the application. This would make it a much more friendly user interface and would seem less intimidating to the average user. Given more time, I would also like to tweak the validation logic. For example, the year and month fields currently do not have any validation which fits with the specification but I think it would improve the application to add this as it could reduce errors. If possible, I'd also choose to connect with the database over SSL so all communication was encrypted and secure. In a production environment, the server containing the database would likely be on the same LAN however so this could be unncessary. 
